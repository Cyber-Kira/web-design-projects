<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../../../css/style.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
  <title>C++</title>
</head>

<body>

  <div class="secondary-color sticky-top">
    <header class="container sticky-top">
      <nav class="navbar navbar-expand-lg navbar-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">С++</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"
            aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-link active" aria-current="page" href="../../../../index.html">Главная</a>
              <a class="nav-link" href="../../../lessons.html">Уроки</a>
            </div>
          </div>
        </div>
      </nav>
    </header>
  </div>

  <main>
    <div class="container-xxl my-md-4 bd-layout">
      <div class="row">
        <div class="col-sm-8 mx-auto">
          <h1>Массивы</h1>
          <p>Массив представляет набор однотипных данных. Формальное определение массива выглядит следующим образом:</p>
          <pre><code>тип_переменной название_массива [длина_массива]</code></pre>
          <p>После типа переменной идет название массива, а затем в квадратных скобках его размер. Например, определим
            массив из 4 чисел:</p>
          <pre><code>int numbers[4];</code></pre>
          <p>Данный массив имеет четыре числа, но все эти числа имеют неопределенное значение. Однако мы можем выполнить
            инициализацию и присвоить этим числам некоторые начальные значения через фигурные скобки:</p>
          <pre><code>int numbers[4] = {1,2,3,4};</code></pre>
          <p>Значения в фигурных скобках еще называют инициализаторами. Если инициализаторов меньше, чем элементов в
            массиве, то инициализаторы используются для первых элементов. Если в инициализаторов больше, чем элементов в
            массиве, то при компиляции возникнет ошибка:</p>
          <pre><code>int numbers[4] = {1, 2, 3, 4, 5, 6};</code></pre>
          <p>Здесь массив имеет размер 4, однако ему передается 6 значений.</p>
          <p>Если размер массива не указан явно, то он выводится из количества инициализаторов:</p>
          <p>int numbers[] = {1, 2, 3, 4, 5, 6};</p>
          <p>В данном случае в массиве есть 6 элементов.</p>
          <p>Свои особенности имеет инициализация символьных массивов. Мы можем передать символьному массиву как набор
            инициализаторов, так и строку:</p>
          <pre>
<code>
char s1[] = {'h', 'e', 'l', 'l', 'o'};
char s2[] = "world";
</code>
</pre>
          <p>Причем во втором случае массив s2 будет иметь не 5 элементов, а 6, поскольку при инициализации строкой в
            символьный массив автоматически добавляется нулевой символ '\0'.</p>
          <p>При этом не допускается присвоение одному массиву другого массива:</p>
          <pre>
<code>
int nums1[] = {1,2,3,4,5};
int nums2[] = nums1;    // ошибка
nums2 = nums1;          // ошибка
</code>
</pre>
          <p>После определения массива мы можем обратиться к его отдельным элементам по индексу. Индексы начинаются с
            нуля, поэтому для обращения к первому элементу необходимо использовать индекс 0. Обратившись к элементу по
            индексу, мы можем получить его значение, либо изменить его:</p>
          <pre>
<code>
#include &lt;iostream>

int main()
{
    int numbers[4] = {1,2,3,4};
    int first_number = numbers[0];
    std::cout << first_number << std::endl; // 1
    numbers[0] = 34;                        // изменяем элемент
    std::cout << numbers[0] << std::endl; // 34
      
    return 0;
}
</code>
</pre>
          <p>Число элементов массива также можно определять через константу:</p>
          <pre>
<code>
const int n = 4;
int numbers[n] = {1,2,3,4};
</code>
</pre>
          <h2>Перебор массивов</h2>
          <p>Используя циклы, можно пробежаться по всему массиву и через индексы обратиться к его элементам:</p>
          <pre>
<code>
#include &lt;iostream>

int main()
{
    int numbers[4] = {1,2,3,4};
    int size = sizeof(numbers)/sizeof(numbers[0]);
    for(int i=0; i < size; i++)
        std::cout << numbers[i] << std::endl;
      
    return 0;
}
</code>
</pre>
          <p>Чтобы пройтись по массиву в цикле, вначале надо найти длину массива. Для нахождения длины применяется
            оператор sizeof. По сути длина массива равна совокупной длине его элементов. Все элементы представляют один
            и тот же тип и занимают один и тот же размер в памяти. Поэтому с помощью выражения sizeof(numbers) находим
            длину всего массива в байтах, а с помощью выражения sizeof(numbers[0]) - длину одного элемента в байтах.
            Разделив два значения, можно получить количество элементов в массиве. А далее с помощью цикла for перебираем
            все элементы, пока счетчик i не станет равным длине массива. В итоге на консоль будут выведены все элементы
            массива:</p>
          <pre>
<code>
1
2
3
4
</code>
</pre>
          <p>Но также есть и еще одна форма цикла for, которая предназначена специально для работа с коллекциями, в том
            числе с массивами. Эта форма имеет следующее формальное определение:</p>
          <pre>
<code>
for(тип переменная : коллекция)
{
    инструкции;
}
</code>
</pre>
          <p>Используем эту форму для перебора массива:</p>
          <pre>
<code>
#include &lt;iostream>

int main()
{
    int numbers[4] = {1,2,3,4};
    for(int number : numbers)
        std::cout << number << std::endl;
          
    return 0;
}
</code>
</pre>
          <p>При переборе массива каждый перебираемый элемент будет помещаться в переменную number, значение которой в
            цикле выводится на консоль.</p>
          <p>Если нам неизвестен тип объектов в массиве, то мы можем использовать спецификатор auto для определения
            типа:</p>
          <pre>
<code>
for(auto number : numbers)
  std::cout << number << std::endl;
</code>
</pre>
          <h2>Многомерные массивы</h2>
          <p>Кроме одномерных массивов в C++ есть многомерные. Элементы таких массивов сами в свою очередь являются
            массивами, в которых также элементы могут быть массивами. Например, определим двухмерный массив чисел:</p>
          <pre><code>int numbers[3][2];</code></pre>
          <p>Такой массив состоит из трех элементов, при этом каждый элемент представляет массив из двух элементов.
            Инициализируем подобный массив:</p>
          <pre><code>int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };</code></pre>
          <p>Вложенные фигурные скобки очерчивают элементы для каждого подмассива. Такой массив еще можно представить в
            виде таблицы:</p>
          <table>
            <tbody>
              <tr>
                <td>1</td>
                <td>2</td>
              </tr>
              <tr>
                <td>4</td>
                <td>5</td>
              </tr>
              <tr>
                <td>7</td>
                <td>8</td>
              </tr>
            </tbody>
          </table>
          <p>Также при инициализации можно опускать фигурные скобки:</p>
          <pre><code>int numbers[3][2] = { 1, 2, 4, 5, 7, 8 };</code></pre>
          <p>Возможна также инициализация не всех элементов, а только некоторых:</p>
          <pre><code>int numbers[3][2] = { {1, 2}, {}, {7} };</code></pre>
          <p>И чтобы обратиться к элементам вложенного массива, потребуется два индекса:</p>
          <pre>
<code>
int numbers[3][2] = { {1, 2}, {3, 4}, {5, 6} };
std::cout << numbers[1][0] << std::endl;    // 3
numbers[1][0] = 12;             // изменение элемента
std::cout << numbers[1][0] << std::endl;    // 12
</code>
</pre>
          <p>Переберем двухмерный массив:</p>
          <pre>
<code>
#include &lt;iostream>

int main()
{
  const int rows = 3, columns = 2;
  int numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} };
  for(int i=0; i < rows; i++)
  {
      for(int j=0; j < columns; j++)
      {
          std::cout << numbers[i] [j] << "\t";
      }
      std::cout << std::endl;
  }
  return 0;
}
</code>
</pre>
          <p>Также для перебора элементов многомерного массива можно использовать другую форму цикла for:</p>
          <pre>
<code>
#include &lt;iostream>

int main()
{
    const int rows = 3, columns = 2;
    int numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} };
      
    for(auto &subnumbers : numbers)
    {
        for(int number : subnumbers)
        {
            std::cout << number << "\t";
        }
        std::cout << std::endl;
    }
          
    return 0;
}
</code>
</pre>
          <p>Для перебора массивов, которые входят в массив, применяются ссылки. То есть во внешнем цикле for(auto
            &subnumbers : numbers) &subnumbers представляет ссылку на подмассив в массиве. Во внутреннем цикле for(int
            number : subnumbers) из каждого подмассива в subnumbers получаем отдельные его элементы в переменную number
            и выводим ее значение на консоль.</p>
          <div class="main__pagination">
            <div class="paginator previous"><a href="./lab1.html">
                <img
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAABRklEQVRoQ+2X4W3CMBCFv0xQRmADugHdpIzQEWCCsgFsUDoBdIOO0BW6AXoSlixInDNtKl91lvIrl/jLy7tnu8Ph6BwyE9B/9ddC6VC6oEDYI+wR9rB5YAY8AQdbeV3VFI04B96Ad2Bdh2Or/m3oR+AISOmNB+gV8HoBlmTNQ79cgPP/2zT0HnjucWOT0PKtGk4p0Teag04JocYbGk1B5wlRyqhmoK8TogQtr+uyjG/g01Kompqc7ksI6zxjdR+F3rh51gothXdjM//g/iTQ4nGndBJRim+BB4OqUu9kqFPJV4X/qzyd5ld6CGYMvJn0SODKaW07F15yOnFqRRT40suKmHO62nvk4O52eUPJ0lwjDvVfnixuoPUxKVnUpC7OiHmyuDqNGxfB+8usG6b7Z5jgyYCeQNTeV4bSoXRBgbBH2OO/2eMMUaUwLofhnv8AAAAASUVORK5CYII=" />
                Лабораторная №1</a></div>
            <div class="paginator next"><a href="./lab3.html">Лабораторная №3<img
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAABUUlEQVRoQ+2X0U3EMBBE31VAC5RAB0AFQAfQAVRwlAAdQCfQAXRACdABGnT5JN6xFfssraV83Tr3Mpkdb3ZMuHYTMpPQvd5aKp1KryiQ9kh7pD3iHrgG3oDv+JZY5ZaN+AhcATfAVwwnVrU19P6g9CXwEUMqV/WAFoUs8gC8lJHKFb2gF5J74LmMtV7RG1o0UvuuBXwEtHiVKmrQqmQZBS1wNWZVsoyEXhrUThYX+gw4CfrxFtBVWnayuNDy4nmJovL3cLIcE7SeValSzPJjgtbh8xR5Sy60PHoauTFwEbTSDyBrFBVe/teFDvL+lWlg0uyxtgSsh7PmkpHQn4DGV3sCHAX9fgCe5kR8Deb3v7bqrXQ4IdYaoRe0nRCjoasSYiS00qEqIUZBT/k17hxEVu2WjWiBOMUJ7ajVUptKt6jn7E2lHbVaalPpFvWcvVMq/QsQrjouZKOwvQAAAABJRU5ErkJggg==" /></a>
            </div>
          </div>
        </div>

      </div>
    </div>
  </main>

  <div class="secondary-color">
    <footer>
      <p class="footer_p">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris elementum sed ante a suscipit.
        Mauris tempor
        suscipit justo vel lacinia. Curabitur hendrerit lobortis ligula nec.</p>
    </footer>
  </div>

  <!-- scripts -->
  <script src="./js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0" crossorigin="anonymous">
  </script>
</body>

</html>