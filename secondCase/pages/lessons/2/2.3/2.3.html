<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../../../css/style.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
  <title>C++</title>
</head>

<body>

  <div class="secondary-color sticky-top">
    <header class="container sticky-top">
      <nav class="navbar navbar-expand-lg navbar-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="#">С++</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"
            aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-link active" aria-current="page" href="../../../../index.html">Главная</a>
              <a class="nav-link" href="../../../lessons.html">Уроки</a>
            </div>
          </div>
        </div>
      </nav>
    </header>
  </div>

  <main>
    <div class="container-xxl my-md-4 bd-layout">
      <div class="row">
        <div class="col-sm"></div>
        <div class="col-sm-7">
          <h1>Типы данных</h1>
          <p>Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная,
            какие операции с ней можно производить и сколько байт в памяти она будет занимать. В языке C++ определены
            следующие базовые типы данных:</p>
          <ul>
            <li><strong>bool</strong>: логический тип. Может принимать одну из двух значений true (истина) и false
              (ложь). Размер занимаемой памяти для этого типа точно не определен.</li>
            <li><strong>char</strong>: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит).
              Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255</li>
            <li><strong>signed char</strong>: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить
              любой значение из диапазона от -128 до 127</li>
            <li><strong>unsigned char</strong>: представляет один символ. Занимает в памяти 1 байт (8 бит). Может
              хранить любой значение из диапазона от 0 до 255</li>
            <li><strong>wchar_t</strong>: представляет расширенный символ. На Windows занимает в памяти 2 байта (16
              бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2
              байтах), либо от 0 до 4 294 967 295 (для 4 байт)</li>
            <li><strong>char16_t</strong>: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16
              бит). Может хранить любой значение из диапазона от 0 до 65 535</li>
            <li><strong>char32_t</strong>: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32
              бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295</li>
            <li><strong>short</strong>: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2
              байта (16 бит).
              <p>Данный тип также имеет синонимы <strong>short int</strong>, <strong>signed short int</strong>,
                <strong>signed short</strong>.</p>
            </li>
            <li><strong>unsigned short</strong>: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2
              байта (16 бит).
              <p>Данный тип также имеет синоним <strong>unsigned short int</strong>.</p>
            </li>
            <li><strong>int</strong>: представляет целое число. В зависимости от архитектуры процессора может занимать 2
              байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может
              варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но
              в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long
              <p>Данный тип имеет синонимы <strong>signed int</strong> и <strong>signed</strong>.</p>
            </li>
            <li><strong>unsigned int</strong>: представляет положительное целое число. В зависимости от архитектуры
              процессора может
              занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может
              меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).
              <p>В качестве синонима этого типа может использоваться <strong>unsigned</strong></p>
            </li>
            <li><strong>long</strong>: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает
              в памяти 4 байта (32 бита).
              <p>У данного типа также есть синонимы long int, signed long int и signed long</p>
            </li>
            <li><strong>unsigned long</strong>: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в
              памяти 4 байта (32 бита).
              <p>Имеет синоним <strong>unsigned long int</strong>.</p>
            </li>
            <li><strong>long long</strong>: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223
              372 036 854 775
              807. Занимает в памяти, как правило, 8 байт (64 бита).
              <p>Имеет синонимы long long int, signed long long int и signed long long.</p>
            </li>
            <li><strong>unsigned long long</strong>: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551
              615. Занимает в
              памяти, как правило, 8 байт (64 бита).
              <p>Имеет синоним <strong>unsigned long long int</strong>.</p>
            </li>
            <li><strong>float</strong>: представляет вещественное число ординарной точности с плавающей точкой в
              диапазоне +/- 3.4E-38 до
              3.4E+38. В памяти занимает 4 байта (32 бита)</li>
            <li><strong>double</strong>: представляет вещественное число двойной точности с плавающей точкой в диапазоне
              +/- 1.7E-308 до
              1.7E+308. В памяти занимает 8 байт (64 бита)</li>
            <li><strong>long double</strong>: представляет вещественное число двойной точности с плавающей точкой не
              менее 8 байт (64
              бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.</li>
            <li><strong>void</strong>: тип без значения</li>
          </ul>
          <p>Таким образом, все типы данных за исключением void могут быть разделены на три группы: символьные (char,
            wchar_t, char16_t, char32_t), целочисленные (short, int, long, long long) и типы чисел с плавающей точкой
            (float, double, long double).</p>
          <h2>Символьные типы</h2>
          <p>Для представления символов в приложении используются типы <strong>char, wchar_t, char16_t и
              char32_t</strong>.</p>
          <p>Определим несколько переменных:</p>
          <pre>
<code>
char c ='d';
wchar_t d ='c';
</code>
</pre>
          <p>Переменная типа char в качестве значения принимает один символ в одинарных кавычках: char c ='d'. Также
            можно присвоить число из указанного выше в списке диапазона: char c = 120. В этом случае значением
            переменной c будет тот символ, который имеет код 120 в таблице символов ASCII.</p>
          <p>Стоит учитывать, что для вывода на консоль символов wchar_t следует использовать не std::cout, а поток
            <strong>std::wcout</strong>:</p>
          <pre>
<code>
#include < iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    std::wcout << a << b << '\n';
    return 0;
}
</code>
</pre>
          <p>При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной
            wchar_t вместо символа будет выводить его числовой код.</p>
          <p>В стандарте С++11 были добавлены типы <strong>char16_t</strong> и <strong>char32_t</strong>, которые
            ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими
            типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо
            преобразовать переменные к типам char или wchar_t:</p>
          <pre>
<code>
#include < iostream>

int main()
{
    char a = 'H';
    wchar_t b = 'e';
    char16_t c = 'l';
    char32_t d = 'o';
    std::cout << a << (char)b << (char)c << (char)d << "\n";
    return 0;
}
</code>
</pre>
          <p>В данном случае при выводе перед переменными указывается операция приведения к типу char - (char),
            благодаря чему значения переменных b, c и d преобразуются в тип char и могут быть выведены на консоль с
            помощью потока std::cout.</p>
          <h2>Целочисленные типы</h2>
          <p>Целочисленные типы представлены следующими типами: <strong>short, unsigned short, int, unsigned int, long,
              unsigned long, long long и unsigned long long</strong>:</p>
          <pre>
<code>
short a = -10;
unsigned short b= 10;
int c = -30;
unsigned int d = 60;
long e = -170;
unsigned long f = 45;
long long g = 89;
</code>
</pre>
          <h2>Типы чисел с плавающей точкой</h2>
          <p>Типы чисел с плавающей точкой иили дробные числа представлены такими типами как <strong>float,
              double</strong> и <strong>long double</strong>:</p>
          <pre>
<code>
float a = -10.45;
double b = 0.00105;
long double c = 30.890045;
</code>
</pre>
          <h2>Размеры типов данных</h2>
          <p>В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит
            отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя
            из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны
            быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита, для типа long
            double. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше
            размера типа short, а размер типа long double должен быть больше double. К примеру, компилятор g++ под
            Windows для long double использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под
            Windows, для long double использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут
            по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны
            выше при описании типов данных.</p>
          <p>Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть
            оператор <strong>sizeof()</strong>, который возвращает размер памяти в байтах, которую занимает переменная:
          </p>
          <pre>
<code>
#include < iostream>

int main()
{
    long double number = 2;
    std::cout << "sizeof(number) =" << sizeof(number);
    return 0;
}
</code>
</pre>
          <p>Консольный вывод при компиляции в g++:</p>
          <pre><code>sizeof(number) = 12</code></pre>
          <p>При этом при определении переменных важно понимать, что значение переменной не должно выходить за те
            пределы, которые очерчены для ее типа. Например:</p>
          <pre><code>unsigned short number = -65535;</code></pre>
          <p>Компилятор G++ при компиляции программы с этой строкой выдаст ошибку о том, что значение -65535 не входит в
            диапазон допустимых значений для типа unsigned short и будет усечено.</p>
          <p>В Visual Studio компиляция может пройти без ошибок, однако при этом переменная number получит значение 2 -
            результат преобразования числа -65535 к типу unsigned short. То есть опять же результат будет не совсем тот,
            который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в
            соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по
            разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной
            значения.</p>
          <h2>Спецификатор auto</h2>
          <p>Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить
            компилятору самому выводить тип объекта. И для этого применяется спецификатор <strong>auto</strong>. При
            этом если мы определяем переменную со спецификатором auto, эта переменная должна быть обязательно
            инициализирована каким-либо значением:</p>
          <pre><code>auto number = 5;</code></pre>
          <p>На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со
            спецификатором auto не допускаются:</p>
          <pre><code>auto number;</code></pre>
          <div class="main__pagination">
            <div class="paginator previous"><a href="./lab1.html">
                <img
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAABRklEQVRoQ+2X4W3CMBCFv0xQRmADugHdpIzQEWCCsgFsUDoBdIOO0BW6AXoSlixInDNtKl91lvIrl/jLy7tnu8Ph6BwyE9B/9ddC6VC6oEDYI+wR9rB5YAY8AQdbeV3VFI04B96Ad2Bdh2Or/m3oR+AISOmNB+gV8HoBlmTNQ79cgPP/2zT0HnjucWOT0PKtGk4p0Teag04JocYbGk1B5wlRyqhmoK8TogQtr+uyjG/g01Kompqc7ksI6zxjdR+F3rh51gothXdjM//g/iTQ4nGndBJRim+BB4OqUu9kqFPJV4X/qzyd5ld6CGYMvJn0SODKaW07F15yOnFqRRT40suKmHO62nvk4O52eUPJ0lwjDvVfnixuoPUxKVnUpC7OiHmyuDqNGxfB+8usG6b7Z5jgyYCeQNTeV4bSoXRBgbBH2OO/2eMMUaUwLofhnv8AAAAASUVORK5CYII=" />
                Лабораторная №1</a></div>
            <div class="paginator next"><a href="./lab3.html">Лабораторная №3<img
                  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAABUUlEQVRoQ+2X0U3EMBBE31VAC5RAB0AFQAfQAVRwlAAdQCfQAXRACdABGnT5JN6xFfssraV83Tr3Mpkdb3ZMuHYTMpPQvd5aKp1KryiQ9kh7pD3iHrgG3oDv+JZY5ZaN+AhcATfAVwwnVrU19P6g9CXwEUMqV/WAFoUs8gC8lJHKFb2gF5J74LmMtV7RG1o0UvuuBXwEtHiVKmrQqmQZBS1wNWZVsoyEXhrUThYX+gw4CfrxFtBVWnayuNDy4nmJovL3cLIcE7SeValSzPJjgtbh8xR5Sy60PHoauTFwEbTSDyBrFBVe/teFDvL+lWlg0uyxtgSsh7PmkpHQn4DGV3sCHAX9fgCe5kR8Deb3v7bqrXQ4IdYaoRe0nRCjoasSYiS00qEqIUZBT/k17hxEVu2WjWiBOMUJ7ajVUptKt6jn7E2lHbVaalPpFvWcvVMq/QsQrjouZKOwvQAAAABJRU5ErkJggg==" /></a>
            </div>
          </div>
        </div>
        <div class="col-sm"></div>
      </div>
    </div>
  </main>

  <div class="secondary-color">
    <footer>
      <p class="footer_p">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris elementum sed ante a suscipit.
        Mauris tempor
        suscipit justo vel lacinia. Curabitur hendrerit lobortis ligula nec.</p>
    </footer>
  </div>

  <!-- scripts -->
  <script src="./js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0" crossorigin="anonymous">
  </script>
</body>

</html>